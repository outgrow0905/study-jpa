#### Persistence Context
JPA에서 중요한 개념인 `Persistence Context`에 대해서 알아보자.

[예시](v1-1_hello-jpa.md)에서는 두 곳에서 `setAge()`를 수행한다.  
그런데 첫 번째 `setAge(20)`에서는 데이터베이스에서 쿼리가 수행되지 않고,    
두 번째 `setAge(21)`에서는 실제 update 쿼리가 수행된다.  

이 차이는 `Persistence Context`에 등록되었는지 여부에 따라 다르게 된다.  
`Persistence Context`는 무엇일까?  
간단하게 `Entity 저장소`라고 생각하자.  
그리고 이는 `EntityManager`를 통해 접근 및 수정이 가능하며 `EntityManager` 1개 당 1개의 `Persistence Context`가 생성된다고 생각하자.  
요약하자면 `EntityManager 별 Entity 저장소`가 되겠다.  
실제로는 여러 `EntityManager`가 같은 `Persistence Context`에 접근할수 있지만 지금은 시작 단계이니 멀티쓰레드 환경은 뒤에서 다루자.  



#### 특성
##### 구조
`Persistence Context`의 구조는 쉽게 `map` 으로 생각하자.    
우리가 `@Entity`에서 지정한 `@Id` 값이 `key`가 되고 객체가 `value`가 된다.  
따라서, `Persistence Context`에서 `@Id` 없이 저장이 안된다.  
또한, 조회할 때에도 `@Id` 단위로 조회해올 수 있다.  
위의 예시에서 `id1`을 통해 조회한 것이 그 이유이다.

##### lifecycle
`Entity`는 네 가지 상태가 존재한다.  
`비영속(new/transient), 영속(managed), 분리(detached), 삭제(removed)` 이다.  

`transient/new`   
쉽게 말하자면 `persist()`가 호출되기 이전상태이다.  
그리고 `Persistence Context`에 등록되기 이전 상태이기도 하다.  
[예시](v1-1_hello-jpa.md)에서 `persist()` 이전에 아무리 많은 `setAge()` 함수가 호출된다 하더라도, 데이터베이스와는 아무런 상관이 없는 평범한 자바 객체일 뿐이다.

`managed`   
`Persistence Context`에 등록된 상태이다.  
[예시](v1-1_hello-jpa.md)에서 `persist()` 호출을 통해 등록된다.  
이때부터는 `setAge()`가 호출되면 실제 `update`가 진행될 수 있다.  
혹은 `find()` 가 호출되면 `Persistence Context`에 해당 `Entity`가 있을 시에 먼저 찾게 된다. 


`detached`  
`Persistence Context`에 등록되었다가 해지된 상태이다.  
사실 이때부터도 마치 `transient` 상태처럼 `Entity`와 데이터베이스는 무관하게 된다.  
`detach()`를 통해 특정 Entity만 `Persistence Context`에서 제거할 수도 있고,    
혹은 `close()`를 통해 아예 `Persistence Context`를 닫을 수도 있다.    
아니면 `clear()`를 통해 `Persistence Context`를 초기화 할수도 있다.


`removed`  
이름은 `Persistence Context`와 관련이 없어보이지만, `delete` 액션과 밀접하다.    
`Persistence Context`에서 `remove()`하게되면 커밋할 시에 `Persistence Context`에서 제거하면서 실제 데이터베이스에서도 해당 데이터를 삭제한다.



#### 사용 시 이점
##### 1차 캐시
~~~java
private void findInCache(EntityManager manager) {
    MemberV1 member = new MemberV1();
    member.setId("id1");
    member.setUsername("name1");
    member.setAge(20);

    // insert
    manager.persist(member);

    // select
    MemberV1 findMember = manager.find(MemberV1.class, "id1");
    log.info("findMember: {}", findMember);
}

private void findInDatabase(EntityManager manager) {
    MemberV1 member = new MemberV1();
    member.setId("id1");
    member.setUsername("name1");
    member.setAge(20);

    // insert
    manager.persist(member);

    // select
    MemberV1 findMember = manager.find(MemberV1.class, "id2");
    log.info("findMember: {}", findMember);
}
~~~
두 코드에서 `find()` 함수가 수행되지만 실제 데이터베이스에서 `select`를 수행하는지 여부는 다르다.    
`findInCache`에서는 `Persistence Context`에 `id1` 키 기준으로 데이터가 있기 때문에 실제 데이터베이스에서 조회하지 않고 이 값을 조회한다.    
`findInDatabase`에서는 `Persistence Context`에 `id2` 키 기준으로 데이터가 없기 때문에 실제 데이터베이스에서 `select`를 수행한다.  
`Persistence Context`가 데이터베이스 조회 전에 1차 캐시 역할을 해주어 성능상 이점을 가져갈 수 있는 것이다.



##### 동일성 보장
~~~java
private void equals(EntityManager manager) {
    MemberV1 member = new MemberV1();
    member.setId("id1");
    member.setUsername("name1");
    member.setAge(20);

    // insert
    manager.persist(member);

    // select
    MemberV1 member1 = manager.find(MemberV1.class, "id1");
    MemberV1 member2 = manager.find(MemberV1.class, "id1");

    log.info("member1: {}", member1.toString());
    log.info("member2: {}", member2.toString());
    log.info("member1 == member2: {}", member1 == member2);
}
~~~
위의 코드에서 로그는 아래와 같이 찍힌다.

![log1](img/log1.png)

`Persistence Context`는 일종의 메모리저장소이다.  
따라서 여기서 가져오는 `member1, member2`는 같은 메모리주소를 가지게 되며 동일성도 보장한다.  
설사 데이터베이스에서 가져온다고해도 동일성은 당연히 보장된다.  
첫번째 `find()`에서는 데이터베이스에서 가져와서 `Persistence Context`에 등록할 것이고,  
두번째 `find()`에서는 첫번째 find에서 `Persistence Context`에 등록된 데이터를 그대로 가져올 것이기 때문이다.  
동일성은 `Persistence Context`가 1차캐시의 역할을 해주면서 부가적으로 가질 수 있는 이점이다. 